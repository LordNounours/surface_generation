import vtk
import os
import json
import tifffile as tiff
from types import SimpleNamespace
import numpy as np
from data_utils import read_csv_files, process_curves, get_radius 
from utils import compute_z_min_max,get_color_from_z_roots,check_memory_usage

def load_config(config_path="config.json"):
    """Loads the configuration from a JSON file."""
    with open(config_path, "r") as f:
        return json.load(f)
    
def generate_cylinder(point_start, point_end, radius):
    """
    Generate a 3D cylinder from two points and a radius.

    The cylinder is generated by sampling the circumference of the cylinder at the two points
    and then connecting these points to form the lateral surface of the cylinder.

    The number of sides of the cylinder is adjusted based on the radius to avoid too few sides for
    a large radius and too many sides for a small radius.

    Parameters:
        point_start (array-like): The starting point of the cylinder.
        point_end (array-like): The ending point of the cylinder.
        radius (float): The radius of the cylinder.

    Returns:
        A list of 3D points that form the cylinder.
    """
    all_points = []
    
    vector = np.array(point_end) - np.array(point_start)
    length = np.linalg.norm(vector)
    if length == 0:
        return []  
    
    direction = vector / length  
    
    # Direction Choice
    if np.allclose(direction, [0, 0, 1]):  
        normal = np.array([1, 0, 0])  
    else:
        normal = np.cross(direction, [0, 0, 1])
        normal /= np.linalg.norm(normal)

    binormal = np.cross(direction, normal)
    if(radius<0) : radius=0
    min_sides = 30  
    max_sides = 500  

    # Adjust the amount_value as you see fit
    dynamic_sides = max(min_sides, min(dynamic_sides, max_sides))  

    # Circle generation
    for i in range(dynamic_sides):
        angle = 2 * np.pi * i / dynamic_sides
        offset = radius * (np.cos(angle) * normal + np.sin(angle) * binormal)
        all_points.append(point_start + offset)
        all_points.append(point_end + offset)

    # Side generation
    heights = np.linspace(0, length, num=int(length * 1))  
    for h in heights:
        center = point_start + direction * h
        for i in range(dynamic_sides):
            angle = 2 * np.pi * i / dynamic_sides
            offset = radius * (np.cos(angle) * normal + np.sin(angle) * binormal)
            all_points.append(center + offset)

    return all_points

def generate_sphere(point, radius, number_of_points=70):
    """
    Generate a 3D sphere from a center point and a radius.

    The sphere is generated by sampling the longitude and latitude of the sphere at the given number of points
    and then computing the 3D coordinates of the points.

    Parameters:
        point (array-like): The center point of the sphere.
        radius (float): The radius of the sphere.
        number_of_points (int): The number of points to sample on the sphere.

    Returns:
        A list of 3D points that form the sphere.
    """
    all_points = []
    u = np.linspace(0, 2 * np.pi, number_of_points)
    v = np.linspace(0, np.pi, number_of_points)

    for i in range(len(u)):
        for j in range(len(v)):
            x = point[0] + radius * np.cos(u[i]) * np.sin(v[j])
            y = point[1] + radius * np.sin(u[i]) * np.sin(v[j])
            z = point[2] + radius * np.cos(v[j])
            all_points.append([x, y, z])

    return all_points



def generate_surface_root(points, dims, color,filename,config):
    """
    Generate a 3D iso-surface from given points and dimensions using VTK.

    This function creates a 3D grid from the input points and dimensions,
    applies Gaussian smoothing, and extracts an iso-surface using Marching 
    Cubes. The resulting iso-surface is saved to a file.

    Parameters:
        points (list): A list of 3D points to generate the surface from.
        dims (tuple): Dimensions of the grid (x, y, z).
        filename (str): The filename to save the generated iso-surface.

    Returns:
        None
    """
    points_np = np.array(points)
    grid = vtk.vtkImageData()
    grid.SetDimensions(dims[0], dims[1], dims[2])
    grid.SetSpacing(1, 1, 1)
    grid.AllocateScalars(vtk.VTK_FLOAT, 1)

    coordinates = points_np[:, :3]
    for x, y, z in coordinates:
        grid.SetScalarComponentFromDouble(int(x), int(y), int(z), 0, 1.0)

    # Memory usage check
    check_memory_usage()

    # Resample of grid
    resampler = vtk.vtkImageResample()  
    resampler.SetInputData(grid)
    resampler.SetAxisMagnificationFactor(0, config.grid_resample_rate)  
    resampler.SetAxisMagnificationFactor(1, config.grid_resample_rate)  
    resampler.SetAxisMagnificationFactor(2, config.grid_resample_rate)  
    resampler.Update()
    grid_resampled = resampler.GetOutput()

    # Gaussian Smoothing 
    gaussian_filter = vtk.vtkImageGaussianSmooth()
    gaussian_filter.SetInputData(grid_resampled)
    gaussian_filter.SetStandardDeviation(config.outer_sigma)  
    gaussian_filter.SetRadiusFactors(3, 3, 3)  
    gaussian_filter.Update()

    # Marching cube
    marchingCubes = vtk.vtkMarchingCubes()
    marchingCubes.SetInputData(gaussian_filter.GetOutput())
    marchingCubes.ComputeNormalsOn()
    marchingCubes.SetValue(0, 0.01)
    marchingCubes.Update()

    isoSurface = marchingCubes.GetOutput()

    writer = vtk.vtkPolyDataWriter()
    writer.SetFileName(f"/home/caro/Documents/Ressources/Annotation_plante_01/mesh/root/test2_cylinder/iso_surface_root{filename}.vtk")
    writer.SetInputData(isoSurface)
    writer.Write()

    check_memory_usage()


def generate_surface_stem(points, dims, color,filename,config):
    """
    Generate a 3D iso-surface of a stem from given points, dimensions, color values, and filename using VTK.

    This function creates a 3D grid from input points and dimensions, applies Gaussian 
    smoothing, and extracts an iso-surface using the Marching Cubes algorithm. The generated 
    iso-surface is colored and saved to a file.

    Parameters:
        points (list): A list of 3D points to generate the surface from.
        dims (tuple): Dimensions of the grid (x, y, z).
        number (int): The number of the stem.
        color (tuple): RGB color values for the iso-surface.
        filename (str): The filename to save the generated iso-surface.

    Returns:
        None
    """
    points_np = np.array(points)
    grid = vtk.vtkImageData()
    grid.SetDimensions(dims[0], dims[1], dims[2])
    grid.SetSpacing(1, 1, 1)
    grid.AllocateScalars(vtk.VTK_FLOAT, 1)

    coordinates = points_np[:, :3]
    for x, y, z in coordinates:
        grid.SetScalarComponentFromDouble(int(x), int(y), int(z), 0, 1.0)

    # Memory Usage Check
    check_memory_usage()

    # Resample
    resampler = vtk.vtkImageResample()  
    resampler.SetInputData(grid)
    resampler.SetAxisMagnificationFactor(0, config.grid_resample_rate)  
    resampler.SetAxisMagnificationFactor(1, config.grid_resample_rate)  
    resampler.SetAxisMagnificationFactor(2, config.grid_resample_rate)  
    resampler.Update()
    grid_resampled = resampler.GetOutput()

    # Gaussian Smoothing
    gaussian_filter = vtk.vtkImageGaussianSmooth()
    gaussian_filter.SetInputData(grid_resampled)
    gaussian_filter.SetStandardDeviation(config.inner_sigma)
    gaussian_filter.SetRadiusFactors(3,3,3)
    gaussian_filter.Update()

    # Marching Cube
    marchingCubes = vtk.vtkMarchingCubes()
    marchingCubes.SetInputData(gaussian_filter.GetOutput())
    marchingCubes.ComputeNormalsOn()
    marchingCubes.SetValue(0, 0.01)
    marchingCubes.Update()

    isoSurface = marchingCubes.GetOutput()
    # Color
    color_array = vtk.vtkUnsignedCharArray()
    color_array.SetNumberOfComponents(3)
    color_array.SetName("Colors")
    for i in range(isoSurface.GetNumberOfPoints()):
        color_array.InsertNextTuple3(int(color[0] * 255), int(color[1] * 255), int(color[2] * 255))
    isoSurface.GetPointData().AddArray(color_array)

    writer = vtk.vtkPolyDataWriter()
    writer.SetFileName(f"/home/caro/Documents/Ressources/Annotation_plante_01/mesh/root/test2_stem/iso_surface_stem{filename}.vtk")
    writer.SetInputData(isoSurface)
    writer.Write()

    check_memory_usage()



def process_roots(curve_points_dict_roots, all_roots_csv_files, radius_points, config, z_min_roots, z_max_roots,dims):
    """Process the roots by generating points (without rendering actors)."""
    for i, filename in enumerate(all_roots_csv_files):
        root_points = []
        stem_points = []
        print(f"Processing: {filename}")

        # Data Loading
        curve_points = curve_points_dict_roots[filename]
        radius_list = radius_points[i]
        curve_color = get_color_from_z_roots(curve_points[0][2], z_min_roots, z_max_roots)
        print(curve_color)

        # Geometry Generation
        x_s, y_s, z_s = [coord for coord in curve_points[0]]
        for j, point in enumerate(curve_points):
            x, y, z = [coord  for coord in point]
            radius = (radius_list[j][1] - 5) 
            sphere_points = generate_sphere([x_s, y_s, z_s], 5)
            for p in sphere_points:
                stem_points.append([*p] + list(curve_color))
            cylinder_points = generate_cylinder([x_s, y_s, z_s], [x, y, z], radius)
            for p in cylinder_points:
                root_points.append([*p] + list(curve_color))
            x_s, y_s, z_s = x, y, z
        generate_surface_stem(stem_points,dims,curve_color,filename,config)
        generate_surface_root(root_points,dims,curve_color,filename,config)

        print(f"Iso-surface saved: iso_surface_{i}.vtk")

def get_dims(tiff_path):
    """
    Lit un fichier TIFF et retourne ses dimensions 

    Parameters
    ----------
    tiff_path : str
        Chemin du fichier TIFF

    Returns
    -------
    tuple of int
        Dimensions du fichier TIFF (z,y,x)
    """
    with tiff.TiffFile(tiff_path) as tif:
        image = tif.asarray()  
        shape = image.shape  
        return shape





def main(config):
    """
    Renders a 3D visualization of plant roots based on a series of CSV files
    contenant des courbes et informations de rayon, puis génère une iso-surface
    utilisant Marching Cubes.
    """

    print("Before Data loading")

    z_dim,y_dim,x_dim=get_dims(config.path_to_test_data + os.sep + config.original_tiff)
    print(x_dim,y_dim,z_dim)
    dims=[x_dim,y_dim,z_dim]
    # Data loading
    all_roots_csv_files = read_csv_files(config.csv_directories_roots, config.path_to_test_data, track_index=False)
    all_z_roots, curve_points_dict_roots = process_curves(all_roots_csv_files, config.csv_directories_roots, config.path_to_test_data, config.curve_sample_root, track_index=False)

    # Calculation of values for colorization
    z_min_roots, z_max_roots = compute_z_min_max(all_z_roots)

    # Root Process
    curve_lengths = [len(curve_points) for curve_points in curve_points_dict_roots.values()]
    radius_points = get_radius(config.path_to_test_data + os.sep + config.radius_path, curve_lengths)
    process_roots(curve_points_dict_roots, all_roots_csv_files, radius_points, config, z_min_roots, z_max_roots,dims)



if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Render a 3D plant model from CSV files.")
    parser.add_argument("config", type=str, nargs="?", default=None, help="Path to the JSON configuration file.")
    args = parser.parse_args()

    # Load the configuration from the JSON
    if(args.config is None):
        # Load from default file (i.e. config.json)
        config_obj = load_config()
    else:
        config_obj = load_config(args.config)
    config = SimpleNamespace(**config_obj)

    # Call the main function with the parameters from the JSON
    main(config)